"""
routes.py

This module defines all FastAPI route handlers for Playlist Pilot,
including:

- Home page with playlist suggestions
- GPT-augmented suggestion flow
- Playlist comparison
- User history view and deletion
- Settings management
"""

from pathlib import Path
from datetime import datetime
import os
from fastapi import APIRouter, Request, Form
from fastapi.responses import HTMLResponse, JSONResponse, FileResponse, RedirectResponse
from fastapi.templating import Jinja2Templates

from config import settings, save_settings
from core.constants import BASE_DIR
from core.history import load_user_history, save_user_history, save_whole_user_history, extract_date_from_label
from core.m3u import write_m3u
from core.playlist import get_playlist_id_by_name, get_playlist_tracks, parse_suggestion_line, get_full_audio_library
from services.gpt import gpt_suggest_validated
from services.jellyfin import fetch_jellyfin_users, search_jellyfin_for_track, fetch_tracks_for_playlist_id
from core.playlist import fetch_audio_playlists, normalize_track, enrich_track
from services.metube import get_youtube_url_single
from core.analysis import summarize_tracks
from utils.cache_manager import playlist_cache, CACHE_TTLS
import openai
from openai import OpenAI
from fastapi import APIRouter, Request
from services.spotify import get_auth_url, get_access_token, get_spotify_client
from spotipy.exceptions import SpotifyException
from spotipy import Spotify

import logging
logger = logging.getLogger("playlist-pilot")

router = APIRouter()
templates = Jinja2Templates(directory=str(BASE_DIR / "templates"))

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# ROUTES

@router.get("/", response_class=HTMLResponse)
async def index(request: Request):
    """
    Render the homepage with a list of audio playlists.
    Uses cached data if available.
    """
    history = load_user_history(settings.jellyfin_user_id)
    cache_key = f"playlists:{settings.jellyfin_user_id}"
    playlists_data = playlist_cache.get(cache_key)

    if playlists_data is None:
        logger.info("Playlist cache miss ‚Äî fetching from Jellyfin")
        playlists_data = fetch_audio_playlists()
        playlist_cache.set(cache_key, playlists_data, expire=CACHE_TTLS["playlists"])
    else:
        logger.info("Playlist cache hit")

    playlists = playlists_data.get("playlists", [])
    return templates.TemplateResponse("index.html", {
        "request": request,
        "settings": settings.dict(),
        "playlists": playlists
    })


@router.post("/suggest", response_class=HTMLResponse)
async def suggest(
    request: Request,
    playlist_name: str = Form(...),
    mood: str = Form("general"),
    suggestion_count: int = Form(10),
    mode: str = Form("augment"),
    genres: str = Form("")
):
    """
    Generate a playlist using GPT and Jellyfin integration.
    """
    try:
        playlist_id = get_playlist_id_by_name(playlist_name)
        existing_tracks = get_playlist_tracks(playlist_id)
        suggestions_raw = await gpt_suggest_validated(existing_tracks, suggestion_count, mood, mode, genres)

        parsed_suggestions = []
        for suggestion in suggestions_raw:
            try:
                text, reason = parse_suggestion_line(suggestion["text"])
                in_jellyfin = search_jellyfin_for_track(suggestion["title"], suggestion["artist"])
                youtube_url = None
                if not in_jellyfin:
                    search_query = f"{suggestion['title']} {suggestion['artist']}"
                    _, youtube_url = await get_youtube_url_single(search_query)
                parsed_suggestions.append({
                    "text": text,
                    "reason": reason,
                    "title": suggestion["title"],
                    "artist": suggestion["artist"],
                    "youtube_url": youtube_url,
                    "in_jellyfin": in_jellyfin
                })
            except Exception as e:
                logger.warning(f"Skipping suggestion: {e}")

        parsed_suggestions.sort(key=lambda s: not s["in_jellyfin"])

        label = f"{playlist_name} ({mode}) @ {datetime.now().strftime('%Y-%m-%d %H:%M')}"
        user_id = settings.jellyfin_user_id
        save_user_history(user_id, label, parsed_suggestions)

        m3u_path = write_m3u([s["text"] for s in parsed_suggestions])

        return templates.TemplateResponse("results.html", {
            "request": request,
            "suggestions": parsed_suggestions,
            "download_link": f"/download/{m3u_path.name}",
            "mode": mode,
            "mood": mood,
            "genres": genres,
            "count": suggestion_count,
            "playlist_name": playlist_name 
        })
    except Exception as e:
        logger.error(f"Error in /suggest: {e}", exc_info=True)
        return templates.TemplateResponse("index.html", {"request": request, "error": str(e)}, status_code=400)

@router.post("/compare", response_class=HTMLResponse)
async def compare_playlists_form(request: Request):
    """
    Compare the overlap between two playlists (GPT or Jellyfin) via HTML form.
    """
    history = load_user_history(settings.jellyfin_user_id)
    history.sort(key=lambda e: extract_date_from_label(e["label"]), reverse=True)
    all_playlists = fetch_audio_playlists()["playlists"]
    try:
        form = await request.form()
        s1_type = form.get("source1_type")
        s1_id = form.get("source1_id")
        s2_type = form.get("source2_type")
        s2_id = form.get("source2_id")

        if not all([s1_type, s1_id, s2_type, s2_id]):
            return templates.TemplateResponse("compare.html", {
                "request": request,
                "history": history,
                "playlists": all_playlists,
                "comparison": ["‚ö†Ô∏è Missing playlist selection."],
                "selected": {
                    "source1_type": s1_type,
                    "source1_id": s1_id,
                    "source2_type": s2_type,
                    "source2_id": s2_id,
                }
            })

        def resolve(source_type, source_id):
            if source_type == "history":
                try:
                    entry = history[int(source_id)]
                    label = entry["label"]
                    tracks = [
                        " - ".join(track["text"].split(" - ")[:2])
                        for track in entry["suggestions"]
                    ]
                    return label, tracks
                except Exception as e:
                    logger.warning(f"‚ùå Failed to resolve GPT history index {source_id}: {e}")
                    return None, []
            elif source_type == "jellyfin":
                try:
                    tracks = fetch_tracks_for_playlist_id(source_id)
                    label = next(
                        (p["name"] for p in all_playlists if p["id"] == source_id),
                        "Jellyfin Playlist"
                    )
                    formatted = [
                        f'{t["Name"]} - {t.get("AlbumArtist") or t.get("Artist", "")}'
                        for t in tracks
                    ]
                    return label, formatted
                except Exception as e:
                    logger.warning(f"‚ùå Failed to resolve Jellyfin playlist {source_id}: {e}")
                    return None, []

        label1, tracks1 = resolve(s1_type, s1_id)
        label2, tracks2 = resolve(s2_type, s2_id)

        if not tracks1 or not tracks2:
            return templates.TemplateResponse("compare.html", {
                "request": request,
                "history": history,
                "playlists": all_playlists,
                "comparison": ["‚ö†Ô∏è One or both playlists could not be resolved."],
                "selected": {
                    "source1_type": s1_type,
                    "source1_id": s1_id,
                    "source2_type": s2_type,
                    "source2_id": s2_id,
                }
            })

        normalize = lambda s: s.lower().strip()
        set1_norm = set(map(normalize, tracks1))
        set2_norm = set(map(normalize, tracks2))

        only_in_1 = sorted([t for t in tracks1 if normalize(t) not in set2_norm])
        only_in_2 = sorted([t for t in tracks2 if normalize(t) not in set1_norm])
        common_tracks = sorted([t for t in tracks1 if normalize(t) in set2_norm])

        comparison = []

        if only_in_1:
            comparison.append({"side": "only_in_1", "label": f"üéµ Only in {label1}", "tracks": only_in_1})
        if only_in_2:
            comparison.append({"side": "only_in_2", "label": f"üé∂ Only in {label2}", "tracks": only_in_2})
        if common_tracks:
            comparison.append({"side": "shared", "label": "‚úÖ Shared Tracks", "tracks": common_tracks})
        if not comparison:
            comparison.append({"label": "‚úÖ The playlists contain the same tracks.", "tracks": [], "side": "shared"})

        return templates.TemplateResponse("compare.html", {
            "request": request,
            "history": history,
            "playlists": all_playlists,
            "comparison": comparison,
            "selected": {
                "source1_type": s1_type,
                "source1_id": s1_id,
                "source2_type": s2_type,
                "source2_id": s2_id,
            }
        })

    except Exception as e:
        logger.exception("Error in compare_playlists_form")
        return templates.TemplateResponse("compare.html", {
            "request": request,
            "history": history,
            "playlists": all_playlists,
            "comparison": [f"‚ùå Unexpected error: {str(e)}"],
            "selected": {
                "source1_type": s1_type,
                "source1_id": s1_id,
                "source2_type": s2_type,
                "source2_id": s2_id,
            }
        })

@router.get("/compare", response_class=HTMLResponse)
async def compare_ui(request: Request):
    history = load_user_history(settings.jellyfin_user_id)
    history.sort(key=lambda e: extract_date_from_label(e["label"]), reverse=True)
    all_playlists = fetch_audio_playlists()["playlists"]
    return templates.TemplateResponse("compare.html", {
        "request": request,
        "history": history,
        "playlists": all_playlists
    })

@router.get("/history", response_class=HTMLResponse)
async def history_page(request: Request):
    """
    Show the user's playlist suggestion history.
    """
    history = load_user_history(settings.jellyfin_user_id)
    history.sort(key=lambda e: extract_date_from_label(e["label"]), reverse=True)
    return templates.TemplateResponse("history.html", {
        "request": request,
        "history": history
    })


@router.post("/history/delete", response_class=HTMLResponse)
async def delete_history(request: Request):
    """
    Delete a playlist entry from the user's history.
    """
    form = await request.form()
    label = form.get("playlist_name")
    try:
        history = load_user_history(settings.jellyfin_user_id)
        updated_history = [item for item in history if item.get("label") != label]
        save_whole_user_history(settings.jellyfin_user_id, updated_history)
        return RedirectResponse(url="/history", status_code=303)
    except Exception as e:
        logger.exception("Error deleting history")
        return JSONResponse(status_code=500, content={"error": str(e)})


@router.api_route("/library-suggest", methods=["GET", "POST"], response_class=HTMLResponse)
async def suggest_from_library(request: Request):
    try:
        # Default values for mood, genres, and mode
        mood = "general"
        genres = ""
        mode = "augment"  # Default mode is augment

        # Initially, no suggestions are generated
        suggestions = []

        # Get full audio library
        library = get_full_audio_library()  # This should now return a list of strings
        # Check if the library has items
        if not library:
            raise ValueError("Library is empty. No items to suggest from.")

        # Check if the form was submitted (POST request)
        if request.method == "POST":
            form_data = await request.form()
            mood = form_data.get("mood", "general")  # Get mood from the form (default is "general")
            genres = form_data.get("genres", "")  # Get genres from the form (default is empty)
            mode = form_data.get("mode", "library")  # Get mode from the form (default is "augment")

            logger.info("Library type: %s", type(library).__name__)
            logger.info("Library sample: %r", library[:3] if isinstance(library, list) else library)

            # Ensure mood and mode are clean strings
            mood = str(mood or "").strip()
            mode = str(mode or "").strip()

            # Clean genres thoroughly
            if genres is None:
                genres_clean = ""
            elif isinstance(genres, list):
                genres_clean = ", ".join(g.strip() for g in genres if isinstance(g, str))
            elif isinstance(genres, str):
                genres_clean = ", ".join(g.strip() for g in genres.split(",") if g.strip())
            else:
                genres_clean = str(genres).strip()

            # Final logging
            logger.info("Calling gpt_suggest_validated with:")
            logger.info("  mood: %r (%s)", mood, type(mood).__name__)
            logger.info("  mode: %r (%s)", mode, type(mode).__name__)
            logger.info("  genres_clean: %r (%s)", genres_clean, type(genres_clean).__name__)


            # Debugging: Check the form data
            print(f"Form Data: mood={mood}, genres={genres}, mode={mode}")

            # Generate GPT prompt based on the mode
            suggestions_raw = await gpt_suggest_validated(
                library,
                count=10,
                mood=str(mood),
                mode=str(mode),
                genres=str(genres_clean)
            )

            # Debugging: Check the raw suggestions returned
            print(f"Raw Suggestions: {suggestions_raw}")

            # Parse suggestions
            parsed_suggestions = []
            for line in suggestions_raw:
                text, reason = parse_suggestion_line(line)
                in_jellyfin = bool(search_jellyfin_for_track(text))
                if in_jellyfin:
                    parsed_suggestions.append({
                        "text": text,
                        "reason": reason,
                        "in_jellyfin": in_jellyfin
                    })

            # Sort suggestions by Jellyfin matches
            parsed_suggestions.sort(key=lambda s: not s["in_jellyfin"])
            suggestions = parsed_suggestions  # Update the suggestions to show after form submission

        # Render response (whether suggestions were generated or not)
        return templates.TemplateResponse(
            "library_suggest.html",
            {
                "request": request,
                "suggestions": suggestions,  # This will be an empty list on the first visit
                "mood": mood,  # Pass the mood to retain the form value
                "genres": genres,  # Pass the genres to retain the form value
                "mode": mode,  # Pass the mode to retain the form value
            }
        )

    except Exception as e:
        logger.exception("Failed to generate suggestions from library")
        return templates.TemplateResponse(
            "library_suggest.html", {
                "request": request,
                "error": str(e),  # Pass error message to the template
                "mood": "general",  # Set default mood in case of an error
                "genres": "",  # Set default genres in case of an error
                "mode": "library",  # Set default mode in case of an error
            },
            status_code=500  # Use 500 status for internal errors
        )


@router.get("/health", response_class=JSONResponse)
async def health_check():
    """
    Simple endpoint for liveness monitoring.
    """
    return {"status": "ok"}


@router.get("/settings", response_class=HTMLResponse)
async def get_settings(request: Request):
    """
    Display current configuration and available Jellyfin users.
    """
    try:
        settings.validate()
        validation_message = None
    except ValueError as ve:
        validation_message = str(ve)
    users = fetch_jellyfin_users()
    client = OpenAI(api_key=settings.openai_api_key)
    models = [
        m.id for m in client.models.list().data
        if m.id.startswith("gpt")
    ]

    return templates.TemplateResponse("settings.html", {
        "request": request,
        "settings": settings.dict(),
        "models": models,
        "validation_message": validation_message,
        "jellyfin_users": users
    })


@router.post("/settings", response_class=HTMLResponse)
async def update_settings(
    request: Request,
    jellyfin_url: str = Form(""),
    jellyfin_api_key: str = Form(""),
    jellyfin_user_id: str = Form(""),
    openai_api_key: str = Form(""),
    lastfm_api_key: str = Form(""),
    model: str = Form("gpt-4o-mini"),
    spotify_client_id: str = Form(""),
    spotify_client_secret: str = Form(""),
    spotify_redirect_uri: str = Form("")
):
    """
    Update application configuration settings from form input.
    """
    settings.jellyfin_url = jellyfin_url
    settings.jellyfin_api_key = jellyfin_api_key
    settings.jellyfin_user_id = jellyfin_user_id
    settings.openai_api_key = openai_api_key
    settings.lastfm_api_key = lastfm_api_key
    settings.model = model
    client = OpenAI(api_key=settings.openai_api_key)
    models = [
        m.id for m in client.models.list().data
        if m.id.startswith("gpt")
    ]
    settings.spotify_client_id = spotify_client_id
    settings.spotify_client_secret = spotify_client_secret
    settings.spotify_redirect_uri = spotify_redirect_uri

    save_settings(settings)

    try:
        settings.validate()
        validation_message = "Settings saved successfully."
    except ValueError as ve:
        validation_message = str(ve)

    users = fetch_jellyfin_users()
    return templates.TemplateResponse("settings.html", {
        "request": request,
        "settings": settings.dict(),
        "validation_message": validation_message,
        "models": models,
        "jellyfin_users": users
    })

@router.post("/api/test/lastfm")
async def test_lastfm(request: Request):
    import httpx
    data = await request.json()
    key = data.get("key", "").strip()

    try:
        async with httpx.AsyncClient() as client:
            r = await client.get("https://ws.audioscrobbler.com/2.0/", params={
                "method": "artist.search",
                "artist": "radiohead",
                "api_key": key,
                "format": "json"
            })

        json_data = r.json()

        return JSONResponse({
            "success": "error" not in json_data,
            "status": r.status_code,
            "body": json_data
        })
    except Exception as e:
        return JSONResponse({"success": False, "error": str(e)})


@router.post("/api/test/jellyfin")
async def test_jellyfin(request: Request):
    import httpx
    import logging
    data = await request.json()
    url = data.get("url", "").rstrip("/")
    key = data.get("key", "")

    try:
        headers = {
            "X-Emby-Token": key,
            "Accept": "application/json",
            "User-Agent": "PlaylistPilotTest/1.0"
        }
        async with httpx.AsyncClient() as client:
            r = await client.get(f"{url}/System/Info", headers=headers)
        
        # DEBUG output
        logging.warning("Jellyfin Test: %s", r.text)

        json_data = r.json()
        valid = r.status_code == 200 and any(k.lower() == "version" for k in json_data)
        return JSONResponse({"success": valid, "status": r.status_code, "data": json_data})
    except Exception as e:
        logging.error("Jellyfin test error: %s", str(e))
        return JSONResponse({"success": False, "error": str(e)})


@router.post("/api/test/openai")
async def test_openai(request: Request):
    data = await request.json()
    key = data.get("key")
    try:
        client = openai.OpenAI(api_key=key)
        models = client.models.list()
        valid = any(m.id.startswith("gpt") for m in models.data)
        return JSONResponse({"success": valid})
    except Exception:
        return JSONResponse({"success": False})

@router.post("/api/test/spotify")
async def test_spotify(request: Request):
    import logging
    import spotipy
    from spotipy.oauth2 import SpotifyClientCredentials

    data = await request.json()
    client_id = data.get("client_id", "").strip()
    client_secret = data.get("client_secret", "").strip()

    logging.warning("[SPOTIFY TEST] Testing Spotify credentials")
    logging.warning("[SPOTIFY TEST] Client ID length: %d", len(client_id))
    logging.warning("[SPOTIFY TEST] Client Secret length: %d", len(client_secret))
    logging.warning("[SPOTIFY TEST] Client ID starts with: %s", client_id[:8])

    try:
        auth_manager = SpotifyClientCredentials(client_id=client_id, client_secret=client_secret)
        sp = spotipy.Spotify(auth_manager=auth_manager)
        result = sp.search(q="radiohead", type="artist", limit=1)  # Simple harmless test call
        logging.warning("[SPOTIFY TEST] API call success: %s", result.get("artists", {}).get("items", [{}])[0].get("name", "N/A"))
        return JSONResponse({"success": True, "data": result})
    except Exception as e:
        logging.exception("Spotify test connection failed")
        return JSONResponse({"success": False, "error": str(e)})


@router.get("/analyze", response_class=HTMLResponse)
async def show_analysis_page(request: Request):
    user_id = settings.jellyfin_user_id
    cache_key = f"playlists:{user_id}"

    playlists_data = playlist_cache.get(cache_key)
    if playlists_data is None:
        playlists_data = fetch_audio_playlists()
        playlist_cache.set(cache_key, playlists_data, expire=CACHE_TTLS["playlists"])

    history = load_user_history(user_id)
    history.sort(key=lambda e: extract_date_from_label(e["label"]), reverse=True)

    return templates.TemplateResponse("analyze.html", {
        "request": request,
        "jellyfin_playlists": playlists_data["playlists"],
        "history": history
    })


@router.post("/analyze/result", response_class=HTMLResponse)
async def analyze_selected_playlist(
    request: Request,
    source_type: str = Form(...),
    playlist_id: str = Form(...)
):
    if source_type == "jellyfin":
         tracks = fetch_tracks_for_playlist_id(playlist_id)
    else:
        history = load_user_history(settings.jellyfin_user_id)
        entry = history[int(playlist_id)]
        suggestions = entry.get("suggestions", [])
        tracks = [s.get("text", "") for s in suggestions if isinstance(s, dict)]
    print("SAMPLE JELLYFIN TRACK:")
    if tracks:
        print(tracks[0])  # show full dict
    print("Normalized Track Sample:", normalize_track(tracks[0]))
    # Normalize + enrich (Phase 2 - level 3 Lastfm only) each track
    enriched = [enrich_track(normalize_track(t)) for t in tracks]

    # Compute listener count stats
    listener_counts = [t["popularity"] for t in enriched if isinstance(t.get("popularity"), int)]

    if listener_counts:
        sorted_counts = sorted(listener_counts)
        n = len(sorted_counts)
        summary = {
            "avg_listeners": sum(sorted_counts) // n,
            "median_listeners": (
                sorted_counts[n // 2] if n % 2 else (sorted_counts[n // 2 - 1] + sorted_counts[n // 2]) // 2
            ),
            "max_listeners": max(sorted_counts)
        }
    else:
        summary = {
            "avg_listeners": 0,
            "median_listeners": 0,
            "max_listeners": 0
        }

    # Add your other metrics (e.g. genre diversity, mood profile, etc.)
    from core.analysis import summarize_tracks
    base_summary = summarize_tracks(enriched)
    summary.update(base_summary)

    return templates.TemplateResponse("analysis_result.html", {
        "request": request,
        "summary": summary,
        "tracks": enriched
    })

@router.get("/auth/spotify")
async def start_spotify_auth():
    """
    Redirects the user to Spotify's OAuth authorization page.
    """
    auth_url = get_auth_url()
    return RedirectResponse(auth_url)

@router.get("/auth/spotify/callback")
async def spotify_callback(request: Request):
    """
    Handles the Spotify OAuth callback with the auth code.
    Exchanges the code for an access token and stores it in the cache.
    """
    code = request.query_params.get("code")
    error = request.query_params.get("error")

    if error:
        print("Spotify auth error:", error)
        return JSONResponse(status_code=400, content={"error": error})

    if not code:
        print("No 'code' param found in callback")
        return JSONResponse(status_code=400, content={"error": "Missing 'code' parameter"})

    try:
        print("Exchanging code for token...")
        token_info = get_access_token(code)
        print("TOKEN INFO:", token_info)

        # Force token caching by creating a Spotify client
        from services.spotify import get_spotify_oauth
        auth_manager = get_spotify_oauth()
        _ = Spotify(auth_manager=auth_manager)

        # Confirm if the file is saved
        import os
        print("Does cache file exist?", os.path.exists("/data/.cache-spotify"))

        return JSONResponse(content={"message": "Spotify authentication successful!"})
    except Exception as e:
        print("Callback exception:", e)
        return JSONResponse(status_code=500, content={"error": str(e)})


@router.get("/auth/spotify/status")
async def spotify_auth_status():
    """
    Returns whether a valid cached token exists and is usable.
    """
    try:
        client = get_spotify_client()
        profile = client.current_user()
        return {
            "authenticated": True,
            "display_name": profile.get("display_name"),
            "id": profile.get("id")
        }
    except SpotifyException:
        return {"authenticated": False}
    except Exception as e:
        return {"authenticated": False, "error": str(e)}

@router.get("/track")
async def get_track_info(q: str):
    from services.spotify import search_track_details
    return search_track_details(q)
